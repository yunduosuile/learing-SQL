196. 删除重复的电子邮箱 Easy

DELETE P1.*
FROM Person P1, Person P2
WHERE P1.Email = P2.Email AND P1.Id > P2.Id

# Delete 语句暂缓, 想法是先使用SELECT查找要删除的行然后换成DELETE

197. 上升的温度 Easy

SELECT w1.Id
FROM Weather w1 JOIN Weather w2
ON DATEDIFF(w1.RecordDate, w2.RecordDate) = 1
WHERE w1.Temperature > w2.Temperature

# DATEDIFF()函数可以得到日期差, 差为第一个日期减去第二个日期

SELECT w1.Id
FROM Weather w1 JOIN Weather w2
ON TIMESTAMPDIFF(Day, w2.RecordDate, w1.RecordDate) = 1
WHERE w1.Temperature > w2.Temperature

# TIMESTAMPDIFF()更通用, 注意TIMESTAMPDIFF()与DATEDIFF()参数的差异

262. 行程和用户 Hard

SELECT Trips.Request_at Day, ROUND(1-SUM(Status = 'completed')/COUNT(Status),2) AS 'Cancellation Rate'
FROM Trips JOIN Users u1
ON Trips.Client_Id = u1.Users_Id
JOIN Users u2 ON Trips.Driver_Id = u2.Users_Id
WHERE u1.Role IN ('client', 'driver') AND u2.Role IN ('client', 'driver') AND u1.Banned = 'No' 
      AND u2.Banned = 'No' AND (Trips.Request_at BETWEEN '2013-10-01' AND '2013-10-03')
GROUP BY Day

# 使用SUM()和COUNT()来计算取消率, 注意WHERE语句中条件较多

511. 游戏玩法分析 I Easy

SELECT player_id, MIN(event_date) AS first_login
FROM Activity
GROUP BY player_id

# 简单, 分组取最小值即可

512. 游戏玩法分析 II Easy

SELECT a1.player_id, a1.device_id
FROM Activity a1
WHERE a1.event_date = (SELECT MIN(event_date)
                       FROM Activity a2
                       WHERE a1.player_id = a2.player_id)

# 使用子查询分组找到最小的日期

534. 游戏玩法分析 III Medium

SELECT A1.player_id, A1.event_date, SUM(A2.games_played) games_played_so_far
FROM Activity A1 JOIN Activity A2
ON A1.player_id = A2.player_id AND A1.event_date >= A2.event_date
GROUP BY A1.player_id, A1.event_date

# 使用自联结的方法可以得出结果

550. 游戏玩法分析 IV Medium

SELECT ROUND(
(SELECT COUNT(A1.player_id)
FROM Activity A1 JOIN Activity A2
ON A1.player_id = A2.player_id AND A1.event_date >= A2.event_date
WHERE DATEDIFF(A1.event_date, A2.event_date) = 1 AND
A2.event_date = (SELECT MIN(event_date)
                 FROM Activity A3
                 WHERE A1.player_id = A3.player_id))
/(SELECT COUNT(DISTINCT player_id) FROM Activity),2) fraction  

# 写好联结一步步慢慢来

569. 员工薪水中位数 Hard


# 卡壳

570. 至少有5名直接下属的经理 Medium

SELECT Name
FROM Employee LEFT JOIN
(SELECT ManagerId, COUNT(ManagerId) num
FROM Employee e1
GROUP BY ManagerId) t1 
ON Employee.Id = t1.ManagerId
WHERE t1.num >= 5

# 先构造满足条件的表然后联结得出结果

571. 给定数字的频率查询中位数 Hard

# 卡壳

